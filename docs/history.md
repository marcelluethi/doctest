# A brief history of software engineering

* Why is it important to have the historical context?
    * It gives the context of an innovation
    * No innovation happens in a vacuum - it always solves a problem that exists at this time
    * Those who do not know history are bound to repeat it
    * It happens very often in computer science

* In this course you will therefore also read a couple of historical research papers in software engineering that changed the field and survived the test of time.

## Short history of software engineering
* Initially we had only programming. How do you get a computer to do what you wnat.
  * Well understood problems such as: how to solve a differential equations
  * Programming usually done by physisists
  * One to one activity: Programmer and computer
* Computer became more commoin in 1950s
  * More people using -> But still a one persons game
* Same time, programmer became a profession. You coudl ask a programmer to write computer program for you
    * Led to separation between user and computer. User had to specify the task such that the programmer could program it.
      * Misinterpretations sometimes happend
    * Only few large software projects were done at that time. (early 1960s)
        *  Example of such a project: CTSS operation system developed at IBM. But all were highly qualified computer pioneers
* Mid 60s, tuly large softwre sysmtes were built commercially.
  * Best known OS 360 from IBM
  * Realization that building large softwrae systems was different from building small ones.
  * Huge difficulties in scaling up techniques from small programm development to large sofware development
* Software engineering was invented at a Nato conference. (CITE)
  * Another term invented in the 60s was "Softwre crisis"
  * Problems discovered:
     * lot of time for communication needed. problems
     * problems when people left
     * large amount of training for new programmers
     * Change in 1 system started effecting another system
     * Changes in a requirement started to impact a large amount of work
   * Many solutions were preposed
     * Different team organization
     * Differnet programming languages
     * Coding conventions,
     * Formal models
     * Final consensus: it is difficult. We need to work on it as engineers
       * Engineers have been able to build large complicated things, such as bridges, skyscrapers,
       * Engineering approach requires management, organization, tools , theories methodologies and techniques
 * It was realized that there were two essential challenges in software engineering: Accidental complexity and essential complexity
   * No silver bullet for essential complexity
 * 1990: Rise of the internet. Computing cheap -> Time to market important -> Millions of users
   * Quickly changing requiremetns: Agile methods
 * Rise of open source
   * New development models - completly distributed. Interaction only via the network
   * Much better programming languages and tools emerging

* 2010 - Now
  * Machine learning, AI, Big data.
